<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Template Renderer</title>
    <!-- Google Fonts - preload common fonts used in designs -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Montserrat:wght@400;500;600;700&family=Poppins:wght@400;500;600;700&family=Open+Sans:wght@400;600;700&family=Roboto:wght@400;500;700&family=Lato:wght@400;700&family=Inter:wght@400;500;600;700&family=Oswald:wght@400;500;700&family=Raleway:wght@400;500;600;700&family=Nunito:wght@400;600;700&display=swap" rel="stylesheet">
    <script>__KONVA_JS__</script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
        }
        #container {
            width: __CANVAS_WIDTH__px;
            height: __CANVAS_HEIGHT__px;
        }
    </style>
</head>
<body>
    <div id="container"></div>

    <script>
        // Template data injected by server
        const templateData = __TEMPLATE_DATA__;
        const canvasWidth = __CANVAS_WIDTH__;
        const canvasHeight = __CANVAS_HEIGHT__;

        // Create Konva stage
        const stage = new Konva.Stage({
            container: 'container',
            width: canvasWidth,
            height: canvasHeight,
        });

        // Create main layer
        const layer = new Konva.Layer();
        stage.add(layer);

        // Draw background
        if (templateData.backgroundColor) {
            const bg = new Konva.Rect({
                x: 0,
                y: 0,
                width: canvasWidth,
                height: canvasHeight,
                fill: templateData.backgroundColor,
            });
            layer.add(bg);
        }

        // Sort layers by position
        const sortedLayers = [...(templateData.layers || [])].sort((a, b) => a.position - b.position);

        // Helper function to load image
        function loadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => resolve(img);
                img.onerror = () => reject(new Error('Failed to load image: ' + src));
                img.src = src;
            });
        }

        // Helper function to tint an image with a color
        // Works best with white/light images on transparent background
        function tintImage(img, tintColor) {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');

            // Draw original image
            ctx.drawImage(img, 0, 0);

            // Apply tint using source-in composite mode
            // This replaces all non-transparent pixels with the tint color
            ctx.globalCompositeOperation = 'source-in';
            ctx.fillStyle = tintColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            return canvas;
        }

        // Render a single layer
        async function renderLayer(layerData) {
            const props = layerData.properties || {};
            const rotation = layerData.rotation || 0;
            const width = layerData.width || 0;
            const height = layerData.height || 0;

            // For rotated elements, adjust position to rotate around center
            // PSD gives us bounding box coordinates, but Konva rotates around (x,y)
            // Use offset to rotate around center instead
            let offsetX = 0;
            let offsetY = 0;
            let adjustedX = layerData.x || 0;
            let adjustedY = layerData.y || 0;

            if (Math.abs(rotation) > 0.1) {
                // Set offset to center of shape
                offsetX = width / 2;
                offsetY = height / 2;
                // Adjust position to account for offset (move to center)
                adjustedX += width / 2;
                adjustedY += height / 2;
            }

            const baseConfig = {
                x: adjustedX,
                y: adjustedY,
                width: width,
                height: height,
                rotation: rotation,
                offsetX: offsetX,
                offsetY: offsetY,
                scaleX: layerData.scale_x || 1,
                scaleY: layerData.scale_y || 1,
                opacity: layerData.opacity ?? 1,
                visible: layerData.visible !== false,
            };

            switch (layerData.type) {
                case 'rectangle': {
                    const rectConfig = {
                        ...baseConfig,
                        stroke: props.stroke || null,
                        strokeWidth: props.strokeWidth || 0,
                        cornerRadius: props.cornerRadius || 0,
                    };

                    // Handle gradient fill
                    if (props.fillType === 'gradient') {
                        const width = layerData.width || 100;
                        const height = layerData.height || 100;
                        const startColor = props.gradientStartColor || '#3B82F6';
                        const endColor = props.gradientEndColor || '#8B5CF6';
                        const startOpacity = props.gradientStartOpacity ?? 1;
                        const endOpacity = props.gradientEndOpacity ?? 1;
                        const angle = props.gradientAngle || 0;

                        // Convert hex to rgba with opacity
                        const hexToRgba = (hex, opacity) => {
                            const r = parseInt(hex.slice(1, 3), 16);
                            const g = parseInt(hex.slice(3, 5), 16);
                            const b = parseInt(hex.slice(5, 7), 16);
                            return `rgba(${r}, ${g}, ${b}, ${opacity})`;
                        };

                        const startColorRgba = hexToRgba(startColor, startOpacity);
                        const endColorRgba = hexToRgba(endColor, endOpacity);

                        if (props.gradientType === 'radial') {
                            rectConfig.fillRadialGradientStartPoint = { x: width / 2, y: height / 2 };
                            rectConfig.fillRadialGradientEndPoint = { x: width / 2, y: height / 2 };
                            rectConfig.fillRadialGradientStartRadius = 0;
                            rectConfig.fillRadialGradientEndRadius = Math.max(width, height) / 2;
                            rectConfig.fillRadialGradientColorStops = [0, startColorRgba, 1, endColorRgba];
                        } else {
                            // Linear gradient
                            // Photoshop angle: 0° = left-to-right, 90° = bottom-to-top
                            // We need to negate the Y component to match Photoshop's coordinate system
                            const angleRad = (angle * Math.PI) / 180;
                            const halfWidth = width / 2;
                            const halfHeight = height / 2;
                            const cos = Math.cos(angleRad);
                            const sin = Math.sin(angleRad);
                            const length = Math.abs(width * cos) + Math.abs(height * sin);

                            // Start at bottom (for 90°), end at top - negate sin for Y axis
                            rectConfig.fillLinearGradientStartPoint = {
                                x: halfWidth - (cos * length) / 2,
                                y: halfHeight + (sin * length) / 2,  // + instead of - (flip Y)
                            };
                            rectConfig.fillLinearGradientEndPoint = {
                                x: halfWidth + (cos * length) / 2,
                                y: halfHeight - (sin * length) / 2,  // - instead of + (flip Y)
                            };
                            rectConfig.fillLinearGradientColorStops = [0, startColorRgba, 1, endColorRgba];
                        }
                    } else {
                        rectConfig.fill = props.fill || '#CCCCCC';
                    }

                    const rect = new Konva.Rect(rectConfig);
                    layer.add(rect);

                    // Apply blur filter if enabled
                    if (props.blurEnabled && props.blurRadius > 0) {
                        rect.cache();
                        rect.filters([Konva.Filters.Blur]);
                        rect.blurRadius(props.blurRadius || 10);
                    }
                    break;
                }

                case 'ellipse': {
                    const ellipse = new Konva.Ellipse({
                        ...baseConfig,
                        radiusX: (layerData.width || 100) / 2,
                        radiusY: (layerData.height || 100) / 2,
                        x: (layerData.x || 0) + (layerData.width || 100) / 2,
                        y: (layerData.y || 0) + (layerData.height || 100) / 2,
                        fill: props.fill || '#CCCCCC',
                        stroke: props.stroke || null,
                        strokeWidth: props.strokeWidth || 0,
                    });
                    layer.add(ellipse);
                    break;
                }

                case 'text': {
                    // Handle text transform (uppercase, lowercase, capitalize)
                    let text = props.text || '';
                    const textTransform = props.textTransform;
                    if (textTransform === 'uppercase') {
                        text = text.toUpperCase();
                    } else if (textTransform === 'lowercase') {
                        text = text.toLowerCase();
                    } else if (textTransform === 'capitalize') {
                        text = text.replace(/\b\w/g, c => c.toUpperCase());
                    }

                    // Handle vertical text direction
                    const textDirection = props.textDirection || 'horizontal';
                    if (textDirection === 'vertical') {
                        text = text.split('').map(char => {
                            if (char === ' ') return '';
                            if (char === '\n') return '\n';
                            return char;
                        }).join('\n');
                    }

                    // Determine if text should have fixed width (word wrap)
                    // Point text (fixedWidth: false) should NOT have width constraint
                    // Paragraph text (fixedWidth: true) should wrap at specified width
                    const hasFixedWidth = props.fixedWidth === true;

                    // Build fontStyle for Konva
                    // Konva fontStyle accepts: 'normal', 'italic', 'bold', 'bold italic', '500', '500 italic', etc.
                    let fontStyle = '';
                    const fontWeight = props.fontWeight || 'normal';
                    const fontStyleValue = props.fontStyle || 'normal';

                    // Add weight first (if not normal)
                    if (fontWeight && fontWeight !== 'normal') {
                        fontStyle = String(fontWeight);
                    }
                    // Add italic if present
                    if (fontStyleValue === 'italic') {
                        fontStyle = fontStyle ? `${fontStyle} italic` : 'italic';
                    }
                    // Default to normal if empty
                    if (!fontStyle) {
                        fontStyle = 'normal';
                    }

                    const textConfig = {
                        x: adjustedX,
                        y: adjustedY,
                        rotation: rotation,
                        offsetX: offsetX,
                        offsetY: offsetY,
                        scaleX: layerData.scale_x || 1,
                        scaleY: layerData.scale_y || 1,
                        opacity: layerData.opacity ?? 1,
                        visible: layerData.visible !== false,
                        text: text,
                        fontSize: props.fontSize || 24,
                        fontFamily: props.fontFamily || 'Arial',
                        fontStyle: fontStyle,
                        fill: props.fill || '#000000',
                        align: props.align || 'left',
                        verticalAlign: props.verticalAlign || 'top',
                        lineHeight: textDirection === 'vertical' ? 0.9 : (props.lineHeight || 1.2),
                        letterSpacing: props.letterSpacing || 0,
                    };

                    // Handle width and wrap settings
                    // Point text (fixedWidth: false) - no word wrapping
                    // Paragraph text (fixedWidth: true) - word wrap at specified width
                    if (hasFixedWidth && layerData.width) {
                        textConfig.width = layerData.width;
                        textConfig.wrap = 'word';
                    } else {
                        // Point text - no wrapping, respects newlines only
                        textConfig.wrap = 'none';
                    }

                    const textNode = new Konva.Text(textConfig);

                    // NOTE: For PSD imports, the x/y position is the bounding box left/top,
                    // NOT the anchor point. So we don't need to adjust based on alignment.
                    // The text should render at the exact x/y position from the PSD.
                    // The alignment property affects how text wraps within a fixed-width box,
                    // but for point text (fixedWidth: false), it's informational only.

                    // We used to adjust position based on alignment, but that was wrong
                    // because PSD bounding boxes already account for the text's actual position.

                    layer.add(textNode);

                    // Apply blur filter if enabled
                    if (props.blurEnabled && props.blurRadius > 0) {
                        textNode.cache();
                        textNode.filters([Konva.Filters.Blur]);
                        textNode.blurRadius(props.blurRadius || 10);
                    }
                    break;
                }

                case 'textbox': {
                    // Draw background rect
                    const padding = props.padding || 16;
                    const bgRect = new Konva.Rect({
                        x: layerData.x || 0,
                        y: layerData.y || 0,
                        width: layerData.width || 200,
                        height: layerData.height || 50,
                        fill: props.fill || '#3B82F6',
                        cornerRadius: props.cornerRadius || 25,
                        rotation: layerData.rotation || 0,
                        scaleX: layerData.scale_x || 1,
                        scaleY: layerData.scale_y || 1,
                        opacity: layerData.opacity ?? 1,
                        visible: layerData.visible !== false,
                    });
                    layer.add(bgRect);

                    // Draw text
                    const textNode = new Konva.Text({
                        x: (layerData.x || 0) + padding,
                        y: (layerData.y || 0) + padding,
                        width: (layerData.width || 200) - padding * 2,
                        height: (layerData.height || 50) - padding * 2,
                        text: props.text || 'Button',
                        fontSize: props.fontSize || 16,
                        fontFamily: props.fontFamily || 'Montserrat',
                        fontStyle: `${props.fontWeight || '600'} ${props.fontStyle || 'normal'}`,
                        fill: props.textColor || '#FFFFFF',
                        align: props.align || 'center',
                        verticalAlign: 'middle',
                        lineHeight: props.lineHeight || 1.1,
                        rotation: layerData.rotation || 0,
                        scaleX: layerData.scale_x || 1,
                        scaleY: layerData.scale_y || 1,
                        opacity: layerData.opacity ?? 1,
                        visible: layerData.visible !== false,
                    });
                    layer.add(textNode);
                    break;
                }

                case 'background':
                case 'image': {
                    if (props.src) {
                        try {
                            let img = await loadImage(props.src);

                            // Apply tint color if specified (for recoloring icon images)
                            if (props.tintColor) {
                                img = tintImage(img, props.tintColor);
                            }

                            // Check if we have a clipPath to apply
                            if (props.clipPath) {
                                // Parse SVG path commands and convert to canvas operations
                                // Konva clipFunc requires manual path drawing, not Path2D
                                const pathData = props.clipPath;

                                // Create a group to apply clipping
                                const clipGroup = new Konva.Group({
                                    x: layerData.x || 0,
                                    y: layerData.y || 0,
                                    rotation: layerData.rotation || 0,
                                    scaleX: layerData.scale_x || 1,
                                    scaleY: layerData.scale_y || 1,
                                    opacity: layerData.opacity ?? 1,
                                    visible: layerData.visible !== false,
                                    clipFunc: (ctx) => {
                                        // Use Path2D to define the clipping region
                                        // We need to trace the path without filling
                                        const path = new Path2D(pathData);
                                        // In Konva clipFunc, we just need to define the path
                                        // The context will use it as a clip region
                                        ctx.beginPath();
                                        // Unfortunately ctx.clip(path) doesn't work in clipFunc
                                        // We need to manually parse and draw the SVG path

                                        // Parse SVG path commands
                                        const commands = pathData.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/gi) || [];
                                        let currentX = 0, currentY = 0;
                                        let startX = 0, startY = 0;

                                        for (const cmd of commands) {
                                            const type = cmd[0];
                                            const args = cmd.slice(1).trim().split(/[\s,]+/).map(parseFloat).filter(n => !isNaN(n));

                                            switch (type) {
                                                case 'M': // Move to (absolute)
                                                    currentX = args[0];
                                                    currentY = args[1];
                                                    startX = currentX;
                                                    startY = currentY;
                                                    ctx.moveTo(currentX, currentY);
                                                    // Handle implicit lineTo commands after M
                                                    for (let i = 2; i < args.length; i += 2) {
                                                        currentX = args[i];
                                                        currentY = args[i + 1];
                                                        ctx.lineTo(currentX, currentY);
                                                    }
                                                    break;
                                                case 'm': // Move to (relative)
                                                    currentX += args[0];
                                                    currentY += args[1];
                                                    startX = currentX;
                                                    startY = currentY;
                                                    ctx.moveTo(currentX, currentY);
                                                    for (let i = 2; i < args.length; i += 2) {
                                                        currentX += args[i];
                                                        currentY += args[i + 1];
                                                        ctx.lineTo(currentX, currentY);
                                                    }
                                                    break;
                                                case 'L': // Line to (absolute)
                                                    for (let i = 0; i < args.length; i += 2) {
                                                        currentX = args[i];
                                                        currentY = args[i + 1];
                                                        ctx.lineTo(currentX, currentY);
                                                    }
                                                    break;
                                                case 'l': // Line to (relative)
                                                    for (let i = 0; i < args.length; i += 2) {
                                                        currentX += args[i];
                                                        currentY += args[i + 1];
                                                        ctx.lineTo(currentX, currentY);
                                                    }
                                                    break;
                                                case 'H': // Horizontal line (absolute)
                                                    for (const x of args) {
                                                        currentX = x;
                                                        ctx.lineTo(currentX, currentY);
                                                    }
                                                    break;
                                                case 'h': // Horizontal line (relative)
                                                    for (const dx of args) {
                                                        currentX += dx;
                                                        ctx.lineTo(currentX, currentY);
                                                    }
                                                    break;
                                                case 'V': // Vertical line (absolute)
                                                    for (const y of args) {
                                                        currentY = y;
                                                        ctx.lineTo(currentX, currentY);
                                                    }
                                                    break;
                                                case 'v': // Vertical line (relative)
                                                    for (const dy of args) {
                                                        currentY += dy;
                                                        ctx.lineTo(currentX, currentY);
                                                    }
                                                    break;
                                                case 'C': // Cubic bezier (absolute)
                                                    for (let i = 0; i < args.length; i += 6) {
                                                        ctx.bezierCurveTo(args[i], args[i+1], args[i+2], args[i+3], args[i+4], args[i+5]);
                                                        currentX = args[i + 4];
                                                        currentY = args[i + 5];
                                                    }
                                                    break;
                                                case 'c': // Cubic bezier (relative)
                                                    for (let i = 0; i < args.length; i += 6) {
                                                        ctx.bezierCurveTo(
                                                            currentX + args[i], currentY + args[i+1],
                                                            currentX + args[i+2], currentY + args[i+3],
                                                            currentX + args[i+4], currentY + args[i+5]
                                                        );
                                                        currentX += args[i + 4];
                                                        currentY += args[i + 5];
                                                    }
                                                    break;
                                                case 'Q': // Quadratic bezier (absolute)
                                                    for (let i = 0; i < args.length; i += 4) {
                                                        ctx.quadraticCurveTo(args[i], args[i+1], args[i+2], args[i+3]);
                                                        currentX = args[i + 2];
                                                        currentY = args[i + 3];
                                                    }
                                                    break;
                                                case 'q': // Quadratic bezier (relative)
                                                    for (let i = 0; i < args.length; i += 4) {
                                                        ctx.quadraticCurveTo(
                                                            currentX + args[i], currentY + args[i+1],
                                                            currentX + args[i+2], currentY + args[i+3]
                                                        );
                                                        currentX += args[i + 2];
                                                        currentY += args[i + 3];
                                                    }
                                                    break;
                                                case 'Z':
                                                case 'z': // Close path
                                                    ctx.closePath();
                                                    currentX = startX;
                                                    currentY = startY;
                                                    break;
                                            }
                                        }
                                    },
                                });

                                // Image is positioned at 0,0 within the group (group handles positioning)
                                const imageNode = new Konva.Image({
                                    x: 0,
                                    y: 0,
                                    width: layerData.width,
                                    height: layerData.height,
                                    image: img,
                                });

                                clipGroup.add(imageNode);
                                layer.add(clipGroup);
                            } else {
                                // No clipPath - render image normally
                                const imageNode = new Konva.Image({
                                    ...baseConfig,
                                    image: img,
                                });

                                // Handle image fit
                                if (props.fit === 'cover') {
                                    const containerWidth = layerData.width || 200;
                                    const containerHeight = layerData.height || 200;
                                    const imgRatio = img.width / img.height;
                                    const containerRatio = containerWidth / containerHeight;

                                    let cropWidth, cropHeight, cropX, cropY;

                                    if (imgRatio > containerRatio) {
                                        cropHeight = img.height;
                                        cropWidth = containerRatio * img.height;
                                        cropX = (img.width - cropWidth) / 2;
                                        cropY = 0;
                                    } else {
                                        cropWidth = img.width;
                                        cropHeight = img.width / containerRatio;
                                        cropX = 0;
                                        cropY = (img.height - cropHeight) / 2;
                                    }

                                    imageNode.crop({
                                        x: cropX,
                                        y: cropY,
                                        width: cropWidth,
                                        height: cropHeight,
                                    });
                                }

                                layer.add(imageNode);
                            }
                        } catch (error) {
                            console.error('Failed to load image:', error);
                            // Draw placeholder rectangle
                            const placeholder = new Konva.Rect({
                                ...baseConfig,
                                fill: '#E5E7EB',
                                stroke: '#9CA3AF',
                                strokeWidth: 1,
                            });
                            layer.add(placeholder);
                        }
                    }
                    break;
                }

                case 'line': {
                    const lineNode = new Konva.Line({
                        x: layerData.x || 0,
                        y: layerData.y || 0,
                        points: props.points || [0, 0, 100, 0],
                        stroke: props.stroke || '#000000',
                        strokeWidth: props.strokeWidth || 2,
                        lineCap: props.lineCap || 'round',
                        lineJoin: props.lineJoin || 'round',
                        dash: props.dash || [],
                        rotation: layerData.rotation || 0,
                        scaleX: layerData.scale_x || 1,
                        scaleY: layerData.scale_y || 1,
                        opacity: layerData.opacity ?? 1,
                        visible: layerData.visible !== false,
                    });
                    layer.add(lineNode);
                    break;
                }

                case 'group':
                    // Groups are handled by their children
                    break;

                default:
                    console.warn('Unknown layer type:', layerData.type);
            }
        }

        // Flatten nested layer structure (groups contain children)
        function flattenLayers(layers) {
            const result = [];
            for (const layerData of layers) {
                if (layerData.type === 'group') {
                    // Recursively process children
                    if (layerData.children && Array.isArray(layerData.children)) {
                        result.push(...flattenLayers(layerData.children));
                    }
                } else {
                    result.push(layerData);
                }
            }
            return result;
        }

        // Get all renderable layers (flattened and sorted)
        const flatLayers = flattenLayers(sortedLayers);
        const renderableLayers = flatLayers.sort((a, b) => (a.position || 0) - (b.position || 0));

        // Render all layers
        async function renderAllLayers() {
            for (const layerData of renderableLayers) {
                if (layerData.visible !== false) {
                    await renderLayer(layerData);
                }
            }
            layer.draw();
        }

        // Start rendering after fonts are loaded
        async function initRender() {
            // Wait for fonts to be ready
            await document.fonts.ready;
            console.log('Fonts loaded, starting render');

            await renderAllLayers();

            // Re-draw after a short delay to ensure fonts are applied
            setTimeout(() => {
                layer.batchDraw();
            }, 100);
        }

        initRender().catch(error => {
            console.error('Render error:', error);
        });
    </script>
</body>
</html>
